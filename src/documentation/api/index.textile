---
layout: default
title: API Documentation
navigation: documentation
---

h2. Transition

Unles otherwise noted, each of the DOM helpers acts on the main frame (the frame dispalying the target web applicaiton being tested).

h6. @Transition.document()@

In the frames based testing framework, this functon returns the main frame.

h3. @Transition.noop()@

This function performs no action, it is useful for declaring states that do not need a trigger function.

h3. @Transition.log(msg)@

This logs a message to the Test Frame's log div.  New messages appear at the top of the div.

h3. @Transition.error(msg)@

This logs an error message to the Test Frame's log div.  New error messages appear at the top of the div.

h3. @Transition.dom@

This returns the document, DOM, of the main frame.

h3. @Transition.findVisibleText(text)@

Finds a dom element in the main frame containing text, which has the jQuery pseudo class @:visible@ (i.e. not hidden).

h3. @Transition.find(selctor)@

Delegates to the jQuery object in the main frame - searches for DOM elements using the given jQuery selector.

h3. @Transition.findText(selctor)@

Delegates to the jQuery object in the main frame, finding the element that matches the selector, returning it's text content.

h3. @Transition.elementExists(selctor)@

In the main frame, tests if the selector finds one or more DOM elements.

h3. @Transition.elementExists_(selctor)@

This is a defered form of @elementExists@, useful in the declaration of transition predicates:

{% highlight javascript %}
  Transition.Stm.newState('viewLogin', Transition.navigateTo_('/login'), {},
    {to: 'doLogin', pred: Transition.elementExists_('input[name=email]') }
  );
{% endhighlight %}

It returns a zero argument function that will test if the given element exists when called.

h3. @Transition.isChecked(selctor)@

Tests if the checkbox or radio button identified by the jQuery selector is checked.

h3. @Transition.isChecked_(selctor)@

Defered form of @isChecked@.

h3. @Transition.isNotChecked(selctor)@

Tests if the checkbox or radio button identified by the jQuery selector is checked.

h3. @Transition.isNotChecked_(selctor)@

Defered form of @isNotChecked@.

h3. @Transition.navigateTo(selector)@

Sets @window.location@ in the main frame.

h3. @Transition.navigateTo_(selector)@

Defered form of @navigateTo@.

h3. @Transition.click(selector)@

'Clicks' on the anchor tag identified by the selector.  This is accomplished by finding the anchor tag, getting its @href@ attribute and then invoking @navigateTo@.

h3. @Transition.clickNode(selector)@

Fires the click handler of the identified dom element.

h3. @Transition.clickNode_(selector)@

Defered version of @clickNode@.

h3. @Transition.propertyExists(object, property)@

Tests if the object has the given property.  This is useful in situations where your test is setting itself up, or you are awaiting a condition that is not visible in the UI.

{% highlight javascript %}
  Transition.Stm.newState('logout', self.doLogout, {start: true},
    {to: 'viewLogin', pred: Transition.propertyExists_(self.state, 'isLoggedOut') }
  );  
{% endhighlight %}

h3. @Transition.propertyExists_(object, property)@

Defered form of @propertyExists@.

h3. @Transition.throw(msg)@

This logs an error and then throws the message.  *Note* throwing will fail the test.


h2. Transition.Stm

h3. @Transition.Stm.start()@

Starts the state machine.

h3. @Transition.Stm.log(msg)@

Defers to @Transition.log@, prending the name of the current state to the message.

h3. @Transition.Stm.terminateTest(status, message)@

Halts the state machine, marking the test as failed.  *Note* this does not effect the current state, it just halts the testing.

h3. @Transition.Stm.pollStates()@

This internal function should not be called by your tests.  It checkes for test timeout and executes the exit prediates of the current state.

h3. @Transition.Stm.summarizeExitPredicates()@

This internal function is used by @pollStates@ when logging.

h3. @Transition.Stm.scheduleNextPoll()@

This internal function is used by @pollStates@ to scheudle the next time to test the transition predicates.

h3. @Transition.Stm.getTimeMs()@

Returns the current time in miliseconds.

h3. @Transition.Stm.elapsedTimeMs()@

Returns the elapsed time since the state machine was started.

h3. @Transition.Stm.newState(name, handler, context, transitions...)@

Adds a state to the state machine.

* name: the name of the state, must be unique within the test.
* handler: a zero argument function that will be called when the state is entered.
* context: a set of properties for the defined state.  The signficant properties are: @start@ which if set to true defines the state as a start state; @stop@ which if set to true defines the state as a terminal state; and @passwd@ which if set to true indicates that the given stop state represents a successful test execution.
@ transitions... the remaining arguments are treated as the transition declarations.

Transition declarations have 2 properties:

* to: the name of the target state
* pred: a zero argument boolean function to indicate the transition should be followed.

h3. @Transition.Stm.stopPolling()@

Stops the polling loop.  This does not cause the test to fail, nor succeed.

h3. @Transition.Stm.compliment(fn)@

Returns a new function that is the logical inversion of the given function.  Assumes a zero agument boolean function.

h3. @Transition.Stm.stopTest()@

Halts the test, allowing it to be continued or stepped.

h3. @Transition.Stm.stepTest()@

Steps the test forward 1 and only 1 state.  *Note* the test may still time out if no exit predicates indicate an edge to follow.

h3. @Transition.Stm.continueTest()@

Resumes the test, all subsequent transitions will happen automatically.

h3. @Transition.Stm.init()@

Initializes the state machine and testing framework.

h3. @Transition.Stm.breakpoint(fn)@

Stops the state machine from progressing past the current state.   This is equivalent to using 'Step' in the interactive Runner.  You can call this from any of your state handlers or transition predicates.

If a function is passed (fn), it will be called.  This makes @breakpoint@ suitable as a wrapper around other functions.

h3. @Transition.Stm.breakpoint_(fn)@

This is a defered version of @breakpoint@, that can also be used as a wrapper around other functions:

{% highlight javascript %}
  Transition.Stm.newState('viewLogin', Transition.breakpoint_(Transition.navigateTo_('/login')), {},
    {to: 'doLogin', pred: Transition.elementExists_('input[name=email]') }
  );
{% endhighlight %}
